<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Morphle — Map-to-Meaning (with Subjects)</title>
<style>
  :root{
    --bg:#111316; --panel:#181b20; --ink:#e7ebf3; --muted:#a7b0c0;
    --accent:#6aa8ff; --good:#2ea043; --bad:#e55353; --warn:#e0a800;
    --chip:#242a33; --chipHover:#2b323d; --focus:#8cc1ff; --red:#e55353;
    /* subject hues */
    --english:#5ea2ff; --science:#2ecc71; --hums:#f5b942; --maths:#b271ff;
  }
  html,body{height:100%;}
  body{
    margin:0; background:var(--bg); color:var(--ink);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    display:flex; align-items:center; justify-content:center; padding:24px;
  }
  .app{width:min(1100px,100%); display:grid; gap:16px;}
  header{display:flex; align-items:center; justify-content:space-between; gap:12px;}
  h1{font-size:22px; letter-spacing:.5px; margin:0;}
  .sub{color:var(--muted); font-size:13px}
  .bar{display:flex; align-items:center; gap:8px; flex-wrap:wrap}
  button{
    background:var(--panel); color:var(--ink); border:1px solid #2a2f37;
    border-radius:10px; padding:10px 14px; font-weight:600; cursor:pointer;
  }
  button:hover{background:#20252c}
  button:focus{outline:2px solid var(--focus); outline-offset:2px}

  /* Difficulty buttons styling */
  .difficulty{
    display:flex;
    gap:6px;
    margin-left:12px;
  }
  .difficulty .diff-btn{
    font-size:13px;
    padding:6px 10px;
    border-radius:8px;
    border:1px solid #2a2f37;
    background:var(--chip);
    color:var(--ink);
    cursor:pointer;
  }
  .difficulty .diff-btn.active{
    background:color-mix(in oklab, var(--accent) 30%, var(--chip));
    border-color:var(--accent);
    color:#fff;
  }
  .board{display:grid; gap:16px; grid-template-columns:1.2fr 1fr;}
  .left, .right{background:var(--panel); border:1px solid #2a2f37; border-radius:14px; padding:16px;}
  .section{display:grid; gap:10px;}
  .section h2{font-size:14px; text-transform:uppercase; letter-spacing:.12em; color:var(--muted); margin:0 0 4px 0;}
  /*
   * Display the morpheme chips in a fixed 7×10 grid. Each chip occupies
   * one column in a seven‑column layout. The container has a maximum
   * height equivalent to roughly ten rows of chips; if there are more
   * morphemes than fit vertically, a scrollbar appears so players can
   * browse through all of them. This ensures the list of affixes and
   * bases/roots remains accessible but doesn’t overwhelm the layout.
   */
  .grid{
    display:grid;
    gap:8px;
    grid-template-columns: repeat(7, 1fr);
    max-height: 420px;
    overflow-y: auto;
  }
  .chip{display:flex; align-items:center; justify-content:space-between; gap:6px;
    background:var(--chip); border:1px solid #2a2f37; border-radius:12px;
    padding:8px 10px; font-weight:600; user-select:none;}
  .chip .mini{font-size:11px; color:var(--muted); font-weight:500}
  .chip:hover{background:var(--chipHover)}
  .chip.correct{background:color-mix(in oklab, var(--good) 20%, var(--chip)); border-color:var(--good)}
  .chip.incorrect{background:var(--bad); color:#ffffff; border-color:var(--bad)}
  .legend{display:flex; gap:10px; align-items:center; color:var(--muted); font-size:12px}
  .legend .swatch{width:14px; height:14px; border-radius:4px; border:1px solid #2a2f37}
  .swatch.good{background:var(--good); border-color:var(--good)}
  .swatch.bad{background:var(--bad)}
  .guessbar{display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:6px;}
  input[type="text"]{
    flex:1; min-width:220px; background:#0e1116; color:var(--ink);
    border:1px solid #2a2f37; border-radius:10px; padding:12px 12px; font-size:16px;
  }
  .rounds{margin-left:auto; color:var(--muted); font-weight:700}
  .hint{background:#12161d; border-left:4px solid var(--warn); padding:10px 12px; border-radius:8px; font-size:14px; color:#f5e3b3;}
  .hintSubject{display:flex; align-items:center; gap:8px; background:#12161d; border-left:4px solid #3a4250; padding:10px 12px; border-radius:8px;}
  .pill{font-size:12px; padding:3px 8px; border-radius:999px; font-weight:700; letter-spacing:.3px; border:1px solid #2a2f37}
  .pill.english{background:color-mix(in oklab, var(--english) 15%, #12161d); color:#dfeaff; border-color:color-mix(in oklab, var(--english) 40%, #2a2f37)}
  .pill.science{background:color-mix(in oklab, var(--science) 15%, #12161d); color:#e9ffef; border-color:color-mix(in oklab, var(--science) 40%, #2a2f37)}
  .pill.hums{background:color-mix(in oklab, var(--hums) 15%, #12161d); color:#fff4e0; border-color:color-mix(in oklab, var(--hums) 40%, #2a2f37)}
  .pill.maths{background:color-mix(in oklab, var(--maths) 15%, #12161d); color:#f2e9ff; border-color:color-mix(in oklab, var(--maths) 40%, #2a2f37)}
  .feed{display:grid; gap:8px; margin-top:6px; max-height:240px; overflow:auto; padding-right:4px;}
  .feed .row{background:#12161a; border:1px solid #22262e; border-radius:10px; padding:8px 10px; display:flex; align-items:center; gap:10px; justify-content:space-between;}
  .row .parts{display:flex; gap:6px; flex-wrap:wrap}
  .part{border:1px dashed #3a404b; padding:3px 8px; border-radius:7px; font-size:13px;}
  .part.good{border-style:solid; border-color:var(--good)}
  .part.bad{border-style:solid; border-color:var(--bad); color:var(--bad)}
  footer{display:flex; justify-content:center; color:var(--muted); font-size:12px; margin-top:4px}
  .reveal{background:#122015; border:1px solid #203724; padding:10px 12px; border-radius:10px;}
  .error{color:var(--red); font-weight:700}
  .small{font-size:12px; color:var(--muted)} .tight{margin-top:-4px}
  @media (max-width:880px){.board{grid-template-columns:1fr;}}
</style>
</head>
<body>
  <div class="app" role="application" aria-label="Morphle game">
    <header>
      <div>
        <h1>Morphle<span class="sub"> — Wordle-style morphology</span></h1>
        <div class="small tight">Now with subject hint: English, Science, Humanities, or Mathematics.</div>
      </div>
      <div class="bar">
        <button id="newGameBtn" aria-label="Start new game">New Game</button>
    <!-- Difficulty selection buttons -->
    <div class="difficulty" role="group" aria-label="Select difficulty">
      <!-- Difficulty buttons display the approximate year levels they target.  The
           "Easy" mode suits grades 5–7, "Medium" suits grades 8–10 and
           "Hard" suits grades 11 and beyond.  These labels are purely
           descriptive and do not affect the underlying difficulty values
           stored in the word bank (which remain 'Easy', 'Medium' or 'Hard'). -->
      <button id="easyBtn" data-difficulty="Easy" class="diff-btn">Easy (Y5–7)</button>
      <button id="mediumBtn" data-difficulty="Medium" class="diff-btn">Medium (Y8–10)</button>
      <button id="hardBtn" data-difficulty="Hard" class="diff-btn">Hard (Y11+)</button>
    </div>
    <!-- Challenge mode toggle: when enabled, players have only 5 guesses.  When
         disabled, guesses are unlimited.  The toggle is a checkbox with a
         descriptive label. -->
    <div class="difficulty" role="group" aria-label="Challenge mode">
      <label style="display:flex; align-items:center; gap:6px; font-size:13px; color:var(--muted)">
        <input type="checkbox" id="challengeToggle" /> Challenge mode (5 guesses)
      </label>
    </div>
      </div>
    </header>

    <div class="board">
      <section class="left section" aria-live="polite">
        <h2>Guess Table — Affixes & Bases</h2>
        <div class="grid" id="tokenGrid" aria-describedby="legend"></div>
        <div class="legend" id="legend">
          <span class="swatch good"></span> correct piece
          <span class="swatch bad"></span> eliminated
        </div>
      </section>

      <section class="right section">
        <h2>Make a Guess</h2>
        <!-- Subject hint appears immediately at the start of the game -->
        <div id="hintSubject" class="hintSubject" role="note" aria-live="polite" style="display:none"></div>

        <div class="guessbar">
          <!-- Input without datalist to hide the full word list -->
          <input id="guessInput" type="text" placeholder="Type your guess…" aria-label="Guess a word" />
          <button id="submitBtn">Submit</button>
          <!-- Additional Hint button to reveal extra hints -->
          <button id="hintBtn" aria-label="Get another hint">Hint</button>
          <span class="rounds" id="roundsLeft">5 rounds left</span>
        </div>
        <div id="error" class="error" role="alert" aria-live="assertive"></div>
        <!-- Affix/Base meaning hints appear after each round -->
        <div id="hint" class="hint" style="display:none"></div>

        <div class="feed" id="feed" aria-live="polite"></div>
      </section>
    </div>

    <div id="reveal" style="display:none">
      <div class="reveal">
        <strong>Secret word:</strong> <span id="secretWord"></span>
        <div class="small">Map to Meaning: <span id="secretMap"></span></div>
        <div class="small">Subject: <span id="secretSubject"></span></div>
      </div>
    </div>

    <footer>Built for prefix–base–suffix “Map to Meaning” practice.</footer>
  </div>

<!-- Load morpheme and word data from external files. The generated word list
     must be loaded before words_data.js so that WORDS_GENERATED is defined. -->
<!-- Accessible words list, curated from PET vocabulary (approx.) for ACARA/QCAA equivalence. -->
<script src="accessible_words.js"></script>
<script src="morphemes_data.js"></script>
<script src="words_data_generated.js"></script>
<script src="words_data.js"></script>
<script>
/* ======== Data: morphemes (type + meaning) ======== */
/* The original MORPHEMES definition is kept for reference but renamed to avoid
   overriding the globally loaded data. */
const MORPHEMES_OLD = {
  /* Prefixes */
  in:{type:'prefix',meaning:'not'}, im:{type:'prefix',meaning:'not'},
  il:{type:'prefix',meaning:'not'}, ir:{type:'prefix',meaning:'not'},
  pre:{type:'prefix',meaning:'before'}, re:{type:'prefix',meaning:'again'},
  trans:{type:'prefix',meaning:'across'}, sub:{type:'prefix',meaning:'under'},
  anti:{type:'prefix',meaning:'against'}, bi:{type:'prefix',meaning:'two'},
  micro:{type:'prefix',meaning:'small'}, tele:{type:'prefix',meaning:'far'},
  auto:{type:'prefix',meaning:'self'}, con:{type:'prefix',meaning:'with; together'},
  peri:{type:'prefix',meaning:'around'},

  /* Bases / roots */
  cred:{type:'base',meaning:'believe'}, dict:{type:'base',meaning:'say; speak'},
  bio:{type:'base',meaning:'life'}, aud:{type:'base',meaning:'hear'},
  vis:{type:'base',meaning:'see'}, demo:{type:'base',meaning:'people'},
  script:{type:'base',meaning:'write'}, scrib:{type:'base',meaning:'write'},
  mobil:{type:'base',meaning:'move'}, port:{type:'base',meaning:'carry'},
  struct:{type:'base',meaning:'build'}, meter:{type:'base',meaning:'measure'},
  psych:{type:'base',meaning:'mind'}, phone:{type:'base',meaning:'sound'},
  scope:{type:'base',meaning:'look'}, geo:{type:'base',meaning:'earth'},
  therm:{type:'base',meaning:'heat'}, photo:{type:'base',meaning:'light'},
  graph:{type:'base',meaning:'write'}, cycle:{type:'base',meaning:'wheel'},
  marine:{type:'base',meaning:'sea'}, chrono:{type:'base',meaning:'time'},

  /* Suffixes */
  ible:{type:'suffix',meaning:'capable of being'}, able:{type:'suffix',meaning:'able to'},
  ion:{type:'suffix',meaning:'act; process'}, logy:{type:'suffix',meaning:'study of'},
  ology:{type:'suffix',meaning:'study of'}, cracy:{type:'suffix',meaning:'rule'},
  ize:{type:'suffix',meaning:'make; render'}, al:{type:'suffix',meaning:'related to'},
  graphy:{type:'suffix',meaning:'writing about'}
};

/* ======== Word bank: word + parts + subject ========
   Subjects: 'English', 'Science', 'Humanities', 'Mathematics'
*/
/* The original WORDS list is kept for reference but renamed to avoid
   overriding the globally loaded data. */
const WORDS_OLD = [
  {word:'incredible',    subject:'English',
    parts:[{type:'prefix',text:'in'},{type:'base',text:'cred'},{type:'suffix',text:'ible'}]},
  {word:'prediction',    subject:'Science',
    parts:[{type:'prefix',text:'pre'},{type:'base',text:'dict'},{type:'suffix',text:'ion'}]},
  {word:'biology',       subject:'Science',
    parts:[{type:'base',text:'bio'},{type:'suffix',text:'logy'}]},
  {word:'audible',       subject:'Science',
    parts:[{type:'base',text:'aud'},{type:'suffix',text:'ible'}]},
  {word:'revision',      subject:'English',
    parts:[{type:'prefix',text:'re'},{type:'base',text:'vis'},{type:'suffix',text:'ion'}]},
  {word:'democracy',     subject:'Humanities',
    parts:[{type:'base',text:'demo'},{type:'suffix',text:'cracy'}]},
  {word:'transcription', subject:'Science',
    parts:[{type:'prefix',text:'trans'},{type:'base',text:'script'},{type:'suffix',text:'ion'}]},
  {word:'immobilize',    subject:'Science',
    parts:[{type:'prefix',text:'im'},{type:'base',text:'mobil'},{type:'suffix',text:'ize'}]},
  {word:'perimeter',     subject:'Mathematics',
    parts:[{type:'prefix',text:'peri'},{type:'base',text:'meter'}]},
  {word:'psychology',    subject:'Humanities',
    parts:[{type:'base',text:'psych'},{type:'suffix',text:'ology'}]},
  {word:'microphone',    subject:'Science',
    parts:[{type:'prefix',text:'micro'},{type:'base',text:'phone'}]},
  {word:'telescope',     subject:'Science',
    parts:[{type:'prefix',text:'tele'},{type:'base',text:'scope'}]},
  {word:'geothermal',    subject:'Science',
    parts:[{type:'base',text:'geo'},{type:'base',text:'therm'},{type:'suffix',text:'al'}]},
  {word:'photograph',    subject:'Science',
    parts:[{type:'base',text:'photo'},{type:'base',text:'graph'}]},
  {word:'autograph',     subject:'English',
    parts:[{type:'prefix',text:'auto'},{type:'base',text:'graph'}]},
  {word:'bicycle',       subject:'Science',
    parts:[{type:'prefix',text:'bi'},{type:'base',text:'cycle'}]},
  {word:'submarine',     subject:'Science',
    parts:[{type:'prefix',text:'sub'},{type:'base',text:'marine'}]},
  {word:'transport',     subject:'Humanities',
    parts:[{type:'prefix',text:'trans'},{type:'base',text:'port'}]},
  {word:'portable',      subject:'Science',
    parts:[{type:'base',text:'port'},{type:'suffix',text:'able'}]},
  {word:'construction',  subject:'Humanities',
    parts:[{type:'prefix',text:'con'},{type:'base',text:'struct'},{type:'suffix',text:'ion'}]},
  {word:'geography',     subject:'Humanities',
    parts:[{type:'base',text:'geo'},{type:'suffix',text:'graphy'}]},
  {word:'chronology',    subject:'Humanities',
    parts:[{type:'base',text:'chrono'},{type:'suffix',text:'logy'}]}
];

/* ======== Merge accessible words with the morphological word list ======== */
// If the global ACCESSIBLE_WORDS array (loaded from accessible_words.js) exists,
// append its entries to the WORDS array loaded from words_data.js. This ensures
// all accessible vocabulary words are eligible as secrets and guesses.  We
// perform the merge before any game logic runs.  If WORDS is undefined
// (which should not happen), we initialise it as an empty array before
// concatenation.
if (typeof window !== 'undefined' && window.ACCESSIBLE_WORDS) {
  if (typeof window.WORDS === 'undefined') {
    window.WORDS = [];
  }
  // Avoid duplicate entries by comparing the word property.  Since
  // ACCESSIBLE_WORDS may contain words already present in the morphological
  // dataset, we filter out duplicates based on lowercase word text.
  const existingWordsSet = new Set(window.WORDS.map(w => w.word.toLowerCase()));
  const toAdd = window.ACCESSIBLE_WORDS.filter(entry => !existingWordsSet.has(entry.word.toLowerCase())).map(entry => {
    // Assign a difficulty level to accessible words based on their number of parts.
    // If no difficulty property exists, we use 1 part → Easy, 2 parts → Medium, 3+ parts → Hard.
    if (!('difficulty' in entry)) {
      const partsCount = Array.isArray(entry.parts) ? entry.parts.length : 1;
      let diff;
      if (partsCount === 1) diff = 'Easy';
      else if (partsCount === 2) diff = 'Medium';
      else diff = 'Hard';
      entry.difficulty = diff;
    }
    // Tag accessible entries so we can distinguish them from generated words
    entry.source = 'accessible';
    return entry;
  });
  window.WORDS = window.WORDS.concat(toAdd);
}

/* ======== Difficulty classification ======== */
/**
 * Compute a difficulty category for a word based on its morphemic
 * structure and length.  Easy words are short and have at most one
 * affix; medium words have two parts or moderate length; hard words
 * include multiple affixes/bases or are unusually long.  This function
 * mirrors the user’s definitions: simple, base/root words are easy;
 * words with multiple affixes and roots or uncommon forms are hard;
 * everything else is medium.
 *
 * @param {Array<{type:string,text:string}>} parts Morpheme parts for the word.
 * @param {string} word The original word.
 * @returns {'Easy'|'Medium'|'Hard'} The computed difficulty.
 */
function classifyDifficulty(parts, word) {
  const baseCount = parts.filter(p => p.type === 'base').length;
  const prefixCount = parts.filter(p => p.type === 'prefix').length;
  const suffixCount = parts.filter(p => p.type === 'suffix').length;
  const totalParts = parts.length;
  const wordLen = word.length;
  // Hard: multiple affixes/bases or long words
  if (totalParts >= 3) return 'Hard';
  if (prefixCount + suffixCount >= 2) return 'Hard';
  if (baseCount >= 2) return 'Hard';
  if (wordLen > 10) return 'Hard';
  // Easy: base only or base plus a single affix, or very short
  if (totalParts === 1) return 'Easy';
  if (totalParts === 2) {
    if ((prefixCount === 1 && suffixCount === 0) || (prefixCount === 0 && suffixCount === 1)) {
      return 'Easy';
    }
  }
  if (wordLen <= 5) return 'Easy';
  // Medium otherwise
  return 'Medium';
}

// Precompute a dynamic difficulty for each word.  We allow parts to be
// provided (as in the pre‑loaded dataset) or derive them via segmentWord.
if (typeof window !== 'undefined' && Array.isArray(window.WORDS)) {
  window.WORDS.forEach(entry => {
    let parts = entry.parts;
    // If parts are missing, segment the word on the fly
    if (!Array.isArray(parts) || parts.length === 0) {
      parts = segmentWord(entry.word);
    }
    // Only assign a dynamic difficulty if one has not been provided.
    if (!("dynamicDifficulty" in entry)) {
      entry.dynamicDifficulty = classifyDifficulty(parts, entry.word);
    }
  });
}

/* ======== Game state ======== */
const ROUNDS_MAX = 5;
let secret = null;               // {word, parts, subject}
let roundsLeft = ROUNDS_MAX;
let tokenState = new Map();      // key "type:text" -> 'unknown' | 'correct' | 'incorrect'
let shownTokens = [];            // list of {type,text}
let hintQueue = [];              // [{type,text,meaning}]
let revealed = false;

// Difficulty setting: can be 'Easy', 'Medium' or 'Hard'. Defaults to 'Easy'.
let selectedDifficulty = 'Easy';

// Toggle for challenge mode; when true, players have only a limited
// number of guesses (5).  When false, guesses are unlimited.
let isChallengeMode = false;

// Track the most recently clicked chip so the Hint button can reveal its meaning
let selectedChip = null;

// Track whether a hint has been used in the current round.  When true,
// additional hint requests will be ignored until the player submits a guess.
let hintUsedThisRound = false;

// Maintain a running list of all hints shown during the current game.
// Each hint is stored as an HTML string.  When the player requests a new
// hint, it is appended to this list and the entire list is re-rendered.
let hintsShown = [];

// Track words guessed in the current game to prevent duplicate guesses.
let guessedWords = new Set();

const els = {
  tokenGrid: document.getElementById('tokenGrid'),
  guessInput: document.getElementById('guessInput'),
  submitBtn: document.getElementById('submitBtn'),
  hintBtn: document.getElementById('hintBtn'),
  roundsLeft: document.getElementById('roundsLeft'),
  feed: document.getElementById('feed'),
  hint: document.getElementById('hint'),
  hintSubject: document.getElementById('hintSubject'),
  error: document.getElementById('error'),
  reveal: document.getElementById('reveal'),
  secretWord: document.getElementById('secretWord'),
  secretMap: document.getElementById('secretMap'),
  secretSubject: document.getElementById('secretSubject'),
  newGameBtn: document.getElementById('newGameBtn')
};

/* ======== Utilities ======== */
const sample = (arr,n) => { const a=arr.slice(); for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a.slice(0,Math.max(0,Math.min(n,a.length))); };
const keyFor = (obj) => `${obj.type}:${obj.text}`;
const morphemeMeaning = (text) => MORPHEMES[text]?.meaning ?? '';
let WORD_LOOKUP = new Map();

/* ======== Rendering ======== */
function renderWordList(){
  els.wordsList.innerHTML = '';
  WORDS.map(w=>w.word).sort().forEach(w=>{
    const opt = document.createElement('option'); opt.value = w; els.wordsList.appendChild(opt);
  });
}

function renderTokens(){
  els.tokenGrid.innerHTML = '';
  shownTokens.forEach(tok=>{
    const chip = document.createElement('div');
    chip.className = `chip ${tokenState.get(keyFor(tok))||''}`;
    chip.setAttribute('data-type', tok.type);
    chip.setAttribute('data-text', tok.text);
    chip.setAttribute('role','button');
    chip.setAttribute('aria-label', `${tok.type} ${tok.text} — ${morphemeMeaning(tok.text)}`);
    chip.tabIndex = 0;
    chip.innerHTML = `<span>${tok.text}</span> <span class="mini">${tok.type}</span>`;
    chip.title = `${tok.type} • ${morphemeMeaning(tok.text) || '—'}`;
    chip.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); }});
    // When a chip is clicked, append its morpheme text to the guess input field.
    chip.addEventListener('click', () => {
      // Append the morpheme text to the guess input field
      els.guessInput.value += tok.text;
      // Remember which chip was clicked so the Hint button can show its meaning
      selectedChip = { type: tok.type, text: tok.text };
      // Keep focus on the input so players can continue typing or submit.
      els.guessInput.focus();
    });
    els.tokenGrid.appendChild(chip);
  });
}

function renderHint(nextHint){
  /*
   * Append the new hint (if provided) to the running list.  Each hint is
   * rendered as its own <div> so that multiple hints can accumulate on
   * screen.  The message depends on the hint type:
   *   - For prefix/base/suffix hints, we use “The <prefix/base/suffix> means …”.
   *   - For a definition hint, we show “The word can be understood as …”.
   *   - For a base‑word hint, we reveal the base/root text.
   * When nextHint is null, we simply refresh the displayed list without
   * adding anything.  If there are no hints yet, the hint panel is hidden.
   */
  if(nextHint){
    let hintHtml;
    if(nextHint.type === 'definition'){
      // Combined definition hint: show the concatenated meaning of all parts
      hintHtml = `Hint: The word can be understood as “${nextHint.meaning}”.`;
    } else if(nextHint.type === 'base-word'){
      // Base-word hint: reveal the root text of the secret word
      hintHtml = `Hint: The base/root of the secret word is <strong>${nextHint.meaning}</strong>.`;
    } else {
      // Standard affix/base hint
      const label = nextHint.type === 'base' ? 'base/root' : nextHint.type;
      hintHtml = `Hint: The <strong>${label}</strong> means “${nextHint.meaning}”.`;
    }
    hintsShown.push(hintHtml);
  }
  if(hintsShown.length === 0){
    els.hint.style.display='none';
    els.hint.innerHTML = '';
  } else {
    els.hint.style.display='block';
    els.hint.innerHTML = hintsShown.map(h => `<div>${h}</div>`).join('');
  }
}

/**
 * Segment an arbitrary word into a sequence of prefix/base/suffix parts.
 *
 * The segmentation algorithm searches for the longest matching prefix at
 * the beginning of the word and the longest matching suffix at the end
 * of the word using the entries from the MORPHEMES dictionary.  The
 * substring between the prefix and suffix (if any) is treated as the
 * base/root.  If no prefix or suffix are found, the entire word is
 * considered a base.  Returned parts are objects with `type` and
 * `text` properties.  This function enables the game to accept and
 * evaluate any guess, even if it does not appear in the pre‑loaded
 * word bank.
 *
 * @param {string} word The word to segment.
 * @returns {Array<{type:string,text:string}>} An array of morpheme parts.
 */
function segmentWord(word){
  const lower = word.toLowerCase();
  const prefixes = Object.keys(MORPHEMES).filter(k => MORPHEMES[k].type === 'prefix');
  const suffixes = Object.keys(MORPHEMES).filter(k => MORPHEMES[k].type === 'suffix');
  // Sort by descending length to prioritise the longest match
  prefixes.sort((a,b) => b.length - a.length);
  suffixes.sort((a,b) => b.length - a.length);
  let pre = null;
  let suf = null;
  let startIndex = 0;
  let endIndex = lower.length;
  // Find the longest prefix match
  for(const p of prefixes){
    if(lower.startsWith(p)){
      pre = p;
      startIndex = p.length;
      break;
    }
  }
  // Find the longest suffix match (search in the remaining string)
  for(const s of suffixes){
    if(lower.endsWith(s) && lower.length - s.length >= startIndex){
      suf = s;
      endIndex = lower.length - s.length;
      break;
    }
  }
  const parts = [];
  if(pre){ parts.push({ type:'prefix', text: pre }); }
  const baseText = lower.slice(startIndex, endIndex);
  if(baseText){ parts.push({ type:'base', text: baseText }); }
  if(suf){ parts.push({ type:'suffix', text: suf }); }
  // If no parts were identified (edge case), return the whole word as base
  if(parts.length === 0){ parts.push({ type:'base', text: lower }); }
  return parts;
}

function renderSubjectHint(subject){
  const el = els.hintSubject;
  const cls = subjectClass(subject);
  el.style.display='flex';
  el.innerHTML = `
    <span>Initial hint:</span>
    <span class="pill ${cls}" aria-label="Subject">${subject}</span>
    <span class="small">This word belongs to the <strong>${subject}</strong> category.</span>
  `;
}

function subjectClass(subject){
  const s = subject.toLowerCase();
  if(s.startsWith('eng')) return 'english';
  if(s.startsWith('sci')) return 'science';
  if(s.startsWith('hum')) return 'hums';
  if(s.startsWith('math')) return 'maths';
  return '';
}

function renderSecretReveal(){
  els.reveal.style.display='block';
  els.secretWord.textContent = secret.word;
  const parts = secret.parts.map(p => `${p.type}:${p.text} (${morphemeMeaning(p.text)})`).join('  •  ');
  els.secretMap.textContent = parts;
  els.secretSubject.textContent = secret.subject;
}

function updateRounds(){
  // Display remaining guesses.  When guesses are unlimited (Infinity),
  // show a meaningful label instead of a number.
  if(!Number.isFinite(roundsLeft)){
    els.roundsLeft.textContent = 'Unlimited guesses';
  } else {
    els.roundsLeft.textContent = `${roundsLeft} guess${roundsLeft===1?'':'es'} left`;
  }
}

/* ======== Game flow ======== */
function newGame(){
  // reset
  // Determine the pool of candidate secret words based on the selected
  // difficulty.  Only words from the accessible vocabulary (source
  // 'accessible') are eligible as secret words.  We use the dynamic
  // difficulty classification computed at load time.  If no words match
  // the chosen difficulty, we fall back to accessible words of any
  // difficulty.  If still none, we use the entire list as a final
  // fallback.
  let available = [];
  if (typeof WORDS !== 'undefined') {
    available = WORDS.filter(w => {
      const difficultyMatch = !selectedDifficulty || w.dynamicDifficulty === selectedDifficulty;
      const sourceMatch = w.source === 'accessible';
      return difficultyMatch && sourceMatch;
    });
  }
  // Relax difficulty if no matches
  if (available.length === 0 && typeof WORDS !== 'undefined') {
    available = WORDS.filter(w => w.source === 'accessible');
  }
  const pool = (available && available.length > 0) ? available : WORDS;
  secret = pool[Math.floor(Math.random() * pool.length)];
  // Rebuild the lookup map to validate guesses.  Include all words (not
  // just those in the pool) so that any word in the merged word bank can
  // be guessed.  Use lowercase keys for case-insensitive lookup.
  WORD_LOOKUP = new Map(WORDS.map(w => [w.word.toLowerCase(), w.parts]));
  // Set the number of guesses based on challenge mode.  In challenge
  // mode, players get five guesses; otherwise, guesses are unlimited
  // (represented by Infinity).
  roundsLeft = isChallengeMode ? 5 : Infinity;
  revealed = false;
  tokenState.clear();
  els.feed.innerHTML = ''; els.error.textContent = ''; els.reveal.style.display='none';
  updateRounds();

  // Reset guessed words so players cannot reuse guesses across games
  guessedWords.clear();

  // Reset selected chip at the start of a new game
  selectedChip = null;

  // Reset hint usage so players can request a hint in the first round
  hintUsedThisRound = false;

  // Clear any previously shown hints and hide the hint panel
  hintsShown = [];
  renderHint(null);

  // Clear the guess input field for a fresh start
  els.guessInput.value = '';

  // Set focus on the input field so players can immediately start typing
  els.guessInput.focus();

  // Re-enable the hint button for the new game
  if(els.hintBtn){
    els.hintBtn.disabled = false;
  }

  // Subject hint shown immediately
  renderSubjectHint(secret.subject);

  // Build token display: include all standard prefixes, suffixes and bases plus the secret’s
  // parts. The display lists are capped at 50 base roots and include all
  // available prefixes and suffixes from the MORPHEMES dictionary.
  const displayPrefixes = Object.entries(MORPHEMES)
    .filter(([txt, meta]) => meta.type === 'prefix')
    .map(([txt]) => txt);
  const displaySuffixes = Object.entries(MORPHEMES)
    .filter(([txt, meta]) => meta.type === 'suffix')
    .map(([txt]) => txt);
  const allBases = Object.entries(MORPHEMES)
    .filter(([txt, meta]) => meta.type === 'base')
    .map(([txt]) => txt);
  // Take the first 50 bases (the most common) for display
  const displayBases = allBases.slice(0, 50);
  // Ensure the secret parts are included in the display lists
  secret.parts.forEach(p => {
    if(p.type === 'base' && !displayBases.includes(p.text)) displayBases.push(p.text);
    if(p.type === 'prefix' && !displayPrefixes.includes(p.text)) displayPrefixes.push(p.text);
    if(p.type === 'suffix' && !displaySuffixes.includes(p.text)) displaySuffixes.push(p.text);
  });
  // Build the shownTokens list: prefixes, bases, suffixes
  shownTokens = [];
  displayPrefixes.forEach(txt => shownTokens.push({ type:'prefix', text: txt }));
  displayBases.forEach(txt => shownTokens.push({ type:'base', text: txt }));
  displaySuffixes.forEach(txt => shownTokens.push({ type:'suffix', text: txt }));

  // Initialize token states to unknown
  shownTokens.forEach(t => tokenState.set(keyFor(t), ''));
  renderTokens();

  // Build hint queue: start with definitions of the secret parts (prefix → base → suffix)
  hintQueue = secret.parts.map(p => ({ type: p.type, text: p.text, meaning: morphemeMeaning(p.text) }));
  // Sort so prefix hints come first, then base, then suffix
  hintQueue.sort((a, b) => (a.type === 'prefix' ? 0 : a.type === 'base' ? 1 : 2) - (b.type === 'prefix' ? 0 : b.type === 'base' ? 1 : 2));
  // Append a combined definition hint: join the meanings of each part into a simple phrase
  const combinedMeaning = secret.parts.map(p => morphemeMeaning(p.text)).join(' ');
  hintQueue.push({ type: 'definition', text: 'definition', meaning: combinedMeaning });
  // Append a base-word hint: reveal the base/root text of the secret
  const basePart = secret.parts.find(p => p.type === 'base');
  if(basePart){
    hintQueue.push({ type: 'base-word', text: basePart.text, meaning: basePart.text });
  }

  // Hide the hint panel until the player requests a hint
  renderHint(null);
}

function compareGuess(guessWord){
  const guessParts = WORD_LOOKUP.get(guessWord.toLowerCase());
  if(!guessParts) return null;
  const secretKeys = new Set(secret.parts.map(p=>keyFor(p)));
  const hits = new Set(); const misses = new Set();
  const partsOut = guessParts.map(p=>{
    const k = keyFor(p); const isHit = secretKeys.has(k);
    (isHit?hits:misses).add(k);
    return {...p, match:isHit};
  });
  return {parts:partsOut, hits, misses};
}

function applyTokenColors(hits, misses){
  hits.forEach(k => tokenState.set(k, 'correct'));
  misses.forEach(k => { if(tokenState.get(k)!=='correct') tokenState.set(k,'incorrect'); });
  renderTokens();
}

function addFeedRow(guessWord, parts){
  const row = document.createElement('div'); row.className = 'row';
  const left = document.createElement('div'); left.textContent = guessWord; left.style.fontWeight='700';
  const right = document.createElement('div'); right.className = 'parts';
  parts.forEach(p=>{
    const tag = document.createElement('span');
    tag.className = `part ${p.match?'good':'bad'}`;
    tag.textContent = `${p.type}:${p.text}`;
    tag.title = MORPHEMES[p.text] ? `${p.type} • ${MORPHEMES[p.text].meaning}` : p.type;
    right.appendChild(tag);
  });
  row.appendChild(left); row.appendChild(right); els.feed.prepend(row);
}

function nextHint(){
  // Reveal the next hint in the queue.  All hints are passed through
  // renderHint() so that they accumulate on screen.  When the queue
  // is exhausted, disable the hint button.
  const next = hintQueue.shift();
  if(!next){
    renderHint(null);
    if(els.hintBtn) els.hintBtn.disabled = true;
    return;
  }
  // Use the unified renderHint() function for all hint types
  renderHint(next);
  // Disable the hint button when no more hints remain
  if(hintQueue.length === 0 && els.hintBtn){
    els.hintBtn.disabled = true;
  }
}

// Show a hint based on a selected chip (affix/base/root). Does not consume the secret hint queue.
function showChipHint() {
  if(!selectedChip) return;
  const { type, text } = selectedChip;
  // Look up the meaning from the MORPHEMES dictionary (if available)
  const meaning = MORPHEMES[text] ? MORPHEMES[text].meaning : '';
  // Render the hint panel
  renderHint({ type, text, meaning });
  // Clear the selected chip so the next Hint click will revert to the normal queue
  selectedChip = null;
}

function handleSubmit(){
  if(revealed) return;
  const guess = (els.guessInput.value||'').trim();
  els.error.textContent = '';
  if(!guess){ els.error.textContent = 'Enter a word.'; return; }
  const lowerGuess = guess.toLowerCase();
  // If the guess appears in the pre‑loaded lookup, use its stored parts;
  // otherwise, segment the guess into prefix/base/suffix.  This allows
  // players to enter any word, even if it is not part of the built‑in
  // word bank.  We normalise to lowercase for comparison and storage.
  let guessParts;
  if(WORD_LOOKUP.has(lowerGuess)){
    guessParts = WORD_LOOKUP.get(lowerGuess);
  } else {
    guessParts = segmentWord(lowerGuess);
    // Cache this segmentation for future guesses so duplicate guesses
    // will be recognised and so the compare function can look it up.
    WORD_LOOKUP.set(lowerGuess, guessParts);
  }
  // Prevent duplicate guesses within a single game
  if(guessedWords.has(lowerGuess)){
    els.error.textContent = 'You\'ve already guessed that word.';
    return;
  }
  // Mark the guess as used
  guessedWords.add(lowerGuess);

  // Compute matches between the guess and secret parts
  const res = compareGuess(guess);
  // res.parts may still be undefined if the compare function cannot
  // retrieve parts; ensure it falls back to the segmentation used above
  const partsForFeed = res && res.parts ? res.parts : guessParts.map(p => {
    const k = keyFor(p);
    const secretKeys = new Set(secret.parts.map(sp => keyFor(sp)));
    return { ...p, match: secretKeys.has(k) };
  });
  // Display the guess and its morpheme parts
  addFeedRow(guess, partsForFeed);
  // Apply colouring to the tokens in the grid based on hits/misses
  if(res){
    applyTokenColors(res.hits, res.misses);
  }

  // Decrement the remaining guesses only in challenge mode (i.e., when
  // roundsLeft is finite).  In unlimited mode, roundsLeft stays at
  // Infinity.
  if(Number.isFinite(roundsLeft)){
    roundsLeft--;
  }
  updateRounds();

  // Reset hint usage for the next round now that a guess has been submitted
  hintUsedThisRound = false;

  // Check win/lose conditions
  if(lowerGuess === secret.word.toLowerCase()){
    els.roundsLeft.textContent = 'You solved it!';
    revealed = true;
    renderSecretReveal();
    return;
  }
  // If guesses are limited, end the game when no guesses remain
  if(Number.isFinite(roundsLeft) && roundsLeft <= 0){
    revealed = true;
    renderSecretReveal();
  }

  // Clear input for next guess and keep focus
  els.guessInput.value = '';
  els.guessInput.focus();
}

/* ======== Wire up ======== */
function init(){
  // No need to populate a datalist; word list is hidden from the player
  // events
  document.getElementById('submitBtn').addEventListener('click', handleSubmit);
  document.getElementById('guessInput').addEventListener('keydown', e=>{ if(e.key==='Enter'){ handleSubmit(); }});
  document.getElementById('newGameBtn').addEventListener('click', newGame);
  // Handle additional hint button
  document.getElementById('hintBtn').addEventListener('click', () => {
    if(revealed) return;
    // Only allow one hint per round.  If a hint has already been used,
    // do nothing further.  The player must make a guess to unlock
    // another hint on the next round.
    if(hintUsedThisRound){
      return;
    }
    // If the player clicked a chip, reveal a hint for that affix/base
    // instead of the next secret hint.  This does not consume the
    // secret hint queue but still counts as the hint for this round.
    if(selectedChip){
      showChipHint();
      hintUsedThisRound = true;
    } else {
      // Otherwise, reveal the next hint from the queue.  This may
      // exhaust the queue and disable the button internally.
      nextHint();
      hintUsedThisRound = true;
    }
  });

  // Difficulty button event listeners
  const diffButtons = document.querySelectorAll('.diff-btn');
  diffButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const selected = btn.getAttribute('data-difficulty');
      selectedDifficulty = selected;
      // Update active classes
      diffButtons.forEach(b => {
        if (b.getAttribute('data-difficulty') === selected) {
          b.classList.add('active');
        } else {
          b.classList.remove('active');
        }
      });
      // Start new game with the new difficulty
      newGame();
    });
  });
  // Set initial active difficulty button
  diffButtons.forEach(b => {
    if (b.getAttribute('data-difficulty') === selectedDifficulty) {
      b.classList.add('active');
    }
  });

  // Challenge mode toggle: enable or disable limited guesses.  When the
  // toggle state changes, update the flag and restart the game to
  // reflect the new limit.  Unlimited mode shows “Unlimited guesses”.
  const challengeToggle = document.getElementById('challengeToggle');
  if(challengeToggle){
    challengeToggle.addEventListener('change', () => {
      isChallengeMode = challengeToggle.checked;
      newGame();
    });
  }
  // start
  newGame();
}
init();
</script>
</body>
</html>
